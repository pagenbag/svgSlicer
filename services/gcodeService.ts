import * as THREE from 'three';
import { SVGLoader } from 'three/examples/jsm/loaders/SVGLoader';
import { PrinterSettings, ModelSettings } from '../types';
import { shapeToSegments, getScanlineIntersections, calculateExtrusion } from '../utils/geometryHelper';

export const generateGCode = async (
  svgContent: string,
  printerSettings: PrinterSettings,
  modelSettings: ModelSettings,
  prefix: string
): Promise<string> => {
  return new Promise((resolve, reject) => {
    try {
      const loader = new SVGLoader();
      const svgData = loader.parse(svgContent);

      const paths = svgData.paths;
      const shapes: THREE.Shape[] = [];

      // Convert SVG paths to Three.js Shapes
      paths.forEach((path) => {
        const pathShapes = SVGLoader.createShapes(path);
        pathShapes.forEach((shape) => {
          shapes.push(shape);
        });
      });

      if (shapes.length === 0) {
        throw new Error("No valid shapes found in SVG.");
      }

      // Calculate Bounding Box to center the print
      const allPoints: THREE.Vector2[] = [];
      shapes.forEach(s => {
        allPoints.push(...s.getPoints());
        s.holes.forEach(h => allPoints.push(...h.getPoints()));
      });
      
      const min = { x: Infinity, y: Infinity };
      const max = { x: -Infinity, y: -Infinity };
      
      allPoints.forEach(p => {
        if (p.x < min.x) min.x = p.x;
        if (p.y < min.y) min.y = p.y;
        if (p.x > max.x) max.x = p.x;
        if (p.y > max.y) max.y = p.y;
      });

      const center = { x: (min.x + max.x) / 2, y: (min.y + max.y) / 2 };
      
      // Standard Bed Center (assuming 220x220 bed, center is 110,110 usually, 
      // but let's assume 0,0 is center of bed for relative logic or 100,100.
      // We will offset points to be centered around (110, 110) or user preference.
      // For simplicity, let's target 100,100 (common Prusa/Ender centerish).
      const bedCenter = { x: 110, y: 110 }; 
      const offsetX = bedCenter.x - center.x * modelSettings.scale;
      const offsetY = bedCenter.y - center.y * modelSettings.scale; 
      // Note: SVG Y is usually down, 3D printers Y is up. We need to flip Y.
      // Let's handle scale and flip during point generation.

      const layers = Math.floor(modelSettings.targetHeight / printerSettings.layerHeight);
      
      let gcode = `; Generated by React SVG Slicer\n`;
      gcode += `; Settings: Nozzle ${printerSettings.nozzleDiameter}mm, Layer ${printerSettings.layerHeight}mm\n`;
      gcode += `; Model: Scale ${modelSettings.scale}, Height ${modelSettings.targetHeight}mm\n\n`;
      
      // User Prefix
      gcode += `; --- User Prefix G-Code ---\n`;
      gcode += prefix + '\n';
      gcode += `; --- End User Prefix ---\n\n`;

      // Standard Start
      gcode += `M104 S${printerSettings.temperature}\n`;
      gcode += `M140 S${printerSettings.bedTemperature}\n`;
      gcode += `G90 ; Absolute positioning\n`;
      gcode += `G21 ; Millimeters\n`;
      gcode += `M109 S${printerSettings.temperature} ; Wait for hotend\n`;
      gcode += `M190 S${printerSettings.bedTemperature} ; Wait for bed\n`;
      gcode += `G28 ; Home all axes\n`;
      gcode += `G1 Z15.0 F${printerSettings.travelSpeed} ; Move up\n\n`;

      let currentE = 0;

      // Flip Y calculation helper
      // SVG (0,0) is top-left. G-Code (0,0) is bottom-left. 
      // We need to mirror Y axis relative to the center.
      const transformPoint = (p: THREE.Vector2 | {x: number, y: number}) => {
         // Apply scale
         const sx = p.x * modelSettings.scale;
         const sy = p.y * modelSettings.scale; 
         
         // Flip Y: In SVG, increasing Y goes down. In printers, increasing Y goes back (up).
         // So we negate SVG Y.
         return {
             x: bedCenter.x + (sx - (center.x * modelSettings.scale)),
             y: bedCenter.y - (sy - (center.y * modelSettings.scale)) 
         };
      };

      for (let layer = 0; layer < layers; layer++) {
        const z = printerSettings.initialLayerHeight + (layer * printerSettings.layerHeight) + printerSettings.zOffset;
        gcode += `; --- Layer ${layer + 1} / ${layers} (Z=${z.toFixed(2)}) ---\n`;
        gcode += `G1 Z${z.toFixed(3)} F${printerSettings.travelSpeed}\n`;

        // Process each shape
        for (const shape of shapes) {
            
            // 1. Perimeters (Walls)
            const points = shape.getPoints();
            if (points.length < 2) continue;

            const start = transformPoint(points[0]);
            
            // Travel to start
            gcode += `G0 X${start.x.toFixed(3)} Y${start.y.toFixed(3)} F${printerSettings.travelSpeed}\n`;
            
            // Extrude perimeter
            // Un-retract if needed (simplified: we assume prime at start of print)

            for (let i = 1; i <= points.length; i++) {
                const p = points[i % points.length]; // Wrap around to close
                const tp = transformPoint(p);
                const prevP = points[(i - 1) % points.length];
                const prevTp = transformPoint(prevP);

                const dist = Math.sqrt(Math.pow(tp.x - prevTp.x, 2) + Math.pow(tp.y - prevTp.y, 2));
                const extrude = calculateExtrusion(
                  dist, 
                  printerSettings.layerHeight, 
                  printerSettings.nozzleDiameter, 
                  printerSettings.filamentDiameter
                ) * printerSettings.extrusionMultiplier;
                
                currentE += extrude;
                gcode += `G1 X${tp.x.toFixed(3)} Y${tp.y.toFixed(3)} E${currentE.toFixed(5)} F${printerSettings.printSpeed}\n`;
            }

            // 2. Infill (Zig-Zag / Scanline)
            if (modelSettings.generateInfill) {
                // Get bounds for this shape (transformed)
                const transformedPoints = points.map(transformPoint);
                // We need to re-convert to segments using transformed points for intersection
                const segments = [];
                for(let i=0; i<transformedPoints.length; i++) {
                    segments.push({
                        p1: transformedPoints[i],
                        p2: transformedPoints[(i+1)%transformedPoints.length]
                    });
                }

                // Handle holes for infill
                 if (shape.holes && shape.holes.length > 0) {
                    shape.holes.forEach(h => {
                         const hPoints = h.getPoints().map(transformPoint);
                         for(let i=0; i<hPoints.length; i++) {
                            segments.push({
                                p1: hPoints[i],
                                p2: hPoints[(i+1)%hPoints.length]
                            });
                        }
                    });
                }

                // Determine Y range
                let shapeMinY = Infinity;
                let shapeMaxY = -Infinity;
                transformedPoints.forEach(p => {
                    if (p.y < shapeMinY) shapeMinY = p.y;
                    if (p.y > shapeMaxY) shapeMaxY = p.y;
                });
                
                // Scanline step (fill density)
                // If 100% solid, step = nozzleDiameter
                // If sparse, step increases. 
                // Let's assume fillDensity determines spacing. 
                // Density 100% -> spacing = nozzleDiameter
                // Density 0% -> No infill
                // Density 20% -> spacing = nozzleDiameter * 5
                
                let spacing = printerSettings.nozzleDiameter;
                if (modelSettings.fillDensity < 100 && modelSettings.fillDensity > 0) {
                   spacing = printerSettings.nozzleDiameter * (100 / modelSettings.fillDensity);
                }

                // Alternate direction for better adhesion
                const angle = (layer % 2 === 0) ? 0 : 90; // Simple 0/90 crosshatch logic could go here, 
                // but simpler implementation is just Y-scanlines for now. 
                // To do proper crosshatch, we'd rotate points, slice, then rotate back.
                // Keeping it simple: Just horizontal lines for MVP.

                for (let y = shapeMinY + spacing; y < shapeMaxY; y += spacing) {
                    const intersections = getScanlineIntersections(y, segments);
                    
                    // Pairs: (0,1), (2,3), etc.
                    for (let k = 0; k < intersections.length - 1; k += 2) {
                        const x1 = intersections[k];
                        const x2 = intersections[k+1];
                        
                        // Travel to start of line
                        gcode += `G0 X${x1.toFixed(3)} Y${y.toFixed(3)} F${printerSettings.travelSpeed}\n`;
                        
                        // Extrude to end of line
                        const dist = Math.abs(x2 - x1);
                        const extrude = calculateExtrusion(
                            dist, 
                            printerSettings.layerHeight, 
                            printerSettings.nozzleDiameter, 
                            printerSettings.filamentDiameter
                        ) * printerSettings.extrusionMultiplier;
                        
                        currentE += extrude;
                        gcode += `G1 X${x2.toFixed(3)} Y${y.toFixed(3)} E${currentE.toFixed(5)} F${printerSettings.printSpeed}\n`;
                    }
                }
            }
        }
      }

      // End G-code
      gcode += `\n; End G-Code\n`;
      gcode += `M104 S0 ; Turn off hotend\n`;
      gcode += `M140 S0 ; Turn off bed\n`;
      gcode += `G91 ; Relative positioning\n`;
      gcode += `G1 Z10 F${printerSettings.travelSpeed} ; Lift nozzle\n`;
      gcode += `G90 ; Absolute positioning\n`;
      gcode += `G1 X0 Y200 ; Present print\n`;
      gcode += `M84 ; Disable motors\n`;

      resolve(gcode);
    } catch (e) {
      reject(e);
    }
  });
};
